<html lang="cmn-hans">

<head>
    <meta content="text/html; charset=UTF-8">
    <meta name="author" content="liujing">
    <title>解数独</title>
    <link rel="stylesheet" type="text/css" href="../assets/index.css">
</head>

<body>
    <div id="header">
        <h1 id="title"><a href="https://jingaz.github.io">jingaz</a></h1>
        <div class="links">
            <a href="" target="_blank">
                <div class="iconfont icon-rss"></div>
            </a>
            <a href="https://github.com/jingaz" target="_blank">
                <div class="iconfont icon-github"></div>
            </a>
            <a href="https://jingaz.github.io/blog/post/about.html" target="_blank">
                <div class="iconfont icon-author"></div>
            </a>
        </div>
    </div>
    <div id="main">
        <div id="post">
            <div class="main">
                <h3 class="date" id="date_for_now">2020/4/6</h3>
                <h1 id="title_text">解数独</h1>

                <div id="content">
                    <p>今天在<a href="https://leetcode-cn.com/problems/sudoku-solver"
                            title="37. 解数独">力扣</a>上刷到一个解数独的题，记录一下回溯法解题步骤，巩固所学。</p>
                    <hr>
                    <p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
                    <ol>
                        <li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>
                        <li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>
                        <li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。
                            空白格用&nbsp;<code>'.'</code>&nbsp;表示。</li>
                    </ol>
                    <p><img src="../media/sudokusvg.png" alt="一个数独" title="一个数独"></p>
                    <p>答案被标成红色。</p>
                    <p><img src="../media/solutionsvg.png" alt="一个数独" title="一个数独"></p>
                    <p>Note:</p>
                    <ul>
                        <li>给定的数独序列只包含数字&nbsp;<code>1-9</code>&nbsp;和字符&nbsp;<code>'.'</code>&nbsp;。</li>
                        <li>你可以假设给定的数独只有唯一解。</li>
                        <li>给定数独永远是&nbsp;<code>9x9</code>&nbsp;形式的。</li>
                        <li>通过次数 <code>23,558</code> | 提交次数 <code>38,768</code></li>
                    </ul>
                    <hr>
                    <p><strong>回溯法的关键在于以下</strong>:</p>
                    <ol>
                        <li><a href="#%E7%8A%B6%E6%80%81%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8">状态表示和存储</a></li>
                        <li><a
                                href="#%E5%BD%93%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90">分析当前的状态是否有效，以及衍生的新状态</a>
                        </li>
                        <li><a
                                href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E8%A1%8D%E7%94%9F%E7%8A%B6%E6%80%81">选择合适的衍生状态作为分支</a>
                        </li>
                    </ol>
                    <p>按流程，数独每个未知的格子里若仅有一个选项则置为相应的值，重新遍历整个数独，
                        遍历完成，若没有未知格子，则返回<code>true</code>，如果数独仍存在未知格子，那么，这些格子的可能值（分支）都大于<code>1</code>个，记为<code>branch</code>，选择最小的一个<code>branch</code>，作为衍生状态，假设这个状态有<code>N</code>个分支，则<code>依次</code>把这<code>N</code>个分支作为递归调用的起点，如果某个分支返回了<code>true</code>，则中断递归，返回最终结果。若所有分支都返回<code>false</code>，表示这个状态无效，返回<code>false</code>。
                    </p>
                    <h4 id="状态表示和存储">状态表示和存储</h4>
                    <p>题目给出的数独使用<code>vector&lt;vector&lt;char&gt;&gt;</code>来保存数独，受此影响，最初也使用<code>vector&lt;vector&lt;char&gt;&gt;</code>来保存数独，每次发现数字则忽视，发现未知格子，就计算所在的行和列以及所在的块空缺的值，最后总是超时，经过分析发现，在每次的遍历中，丢掉了大量的信息，导致重复遍历，后来定义一个数据结构来保存状态：最开始，扫描这个数独，发现<code>board[i][j]=k</code>，就更新<code>row[i]</code>、<code>col[j]</code>、<code>block[i/3*3+j/3]</code>,避免重复扫描计算未知格子的待选值，状态定义如下：
                    </p>
                    <pre><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">statue</span> {</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; row;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; col;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; block;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board;

    statue(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; r, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; c,
           <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; b, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; bo)
        : row(r), col(c), block(b), board(bo) {}
};</code></pre>
                    <h4 id="当前的状态分析">当前的状态分析</h4>
                    <p>遍历整个数独，如果发现一个未知的格子<code>board[i][j]=='.'</code>，就检查<code>row[i]</code>,<code>col[j]</code>,<code>block[i/3*3+j/3]</code>，若包含了<code>'1'~'9'</code>，则确定为无效状态，返回<code>false</code>,若仅有一个字符<code>x</code>不包含在内，则确定了<code>board[i][j]=x</code>，重新遍历整个数独，找到所有上述“仅有一个字符<code>x</code>不包含在内”的情况，如果数独最后仍然存在未知格子，就需要选择合格的衍生状态。
                    </p>
                    <h4 id="选择合适的衍生状态">选择合适的衍生状态</h4>
                    <p>现在每个格子的待选值都超过<code>1</code>个，按照概率论，<code>9-&gt;1</code>和<code>2-&gt;1</code>，显然后者命中的概率更大，所以待选值最少的格子作为新状态起点。之前用栈、优先队列等容器保存了全部衍生状态，后来发现，用一个<code>int min_branch</code>就能完成状态比较，过程类似于线性查找数组中的最小值。仅保存<code>branch</code>最小的衍生状态即可。最后<strong>依次</strong>递归调用，检查每个衍生状态是否可行。
                    </p>
                    <p>一通操作猛如虎，一看结果5% (｡•́︿•̀｡)
                        <img src="https://img.vim-cn.com/0a/878e8a49a9c55796e5c540fbb4968cdff4005c.png" alt="运行结果"
                            title="一个菜鸡">
                    </p>
                    <hr>
                    <p>完整代码如下：</p>
                    <pre><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_Sudoku</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;)</span></span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">statue</span> {</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; row;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; col;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; block;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board;

    statue(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; r, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; c,
           <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; b, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; bo)
        : row(r), col(c), block(b), board(bo) {}
};

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">resolve</span><span class="hljs-params">(<span class="hljs-built_in">stack</span>&lt;statue&gt; &amp;status)</span> </span>{

    statue current = status.top();
    status.pop();

scanning:
    <span class="hljs-built_in">vector</span>&lt;statue&gt; tmp_status;
    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">int</span> min_option = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
            <span class="hljs-keyword">if</span> (current.board[i][j] == <span class="hljs-string">'.'</span>) {
                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; val;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">'1'</span>; c &lt;= <span class="hljs-string">'9'</span>; c++) {
                    <span class="hljs-keyword">if</span> (!(current.row[i].count(c) || current.col[j].count(c) ||
                          current.block[i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>].count(c))) {
                        val.push_back(c);
                    }
                }
                <span class="hljs-keyword">if</span> (val.size() == <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">char</span> val_elem = val.back();
                    current.board[i][j] = val_elem;
                    current.row[i].insert(val_elem);
                    current.col[j].insert(val_elem);
                    current.block[i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>].insert(val_elem);
                    <span class="hljs-keyword">goto</span> scanning;
                    <span class="hljs-comment">// 一个无效状态</span>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val.empty()) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (val.size() &lt; min_option) {
                        min_option = val.size();
                        tmp_status.clear();
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> it : val) {
                            statue new_statu = current;
                            new_statu.row[i].insert(it);
                            new_statu.col[j].insert(it);
                            new_statu.block[i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>].insert(it);
                            new_statu.board[i][j] = it;
                            tmp_status.push_back(new_statu);
                        }
                    }

                    ans = <span class="hljs-literal">false</span>;
                }
            }
        }
    }

    <span class="hljs-keyword">if</span> (ans) {
        status.push(current);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">while</span> (!tmp_status.empty()) {
        statue sta = tmp_status.back();
        tmp_status.pop_back();
        status.push(sta);
        <span class="hljs-keyword">if</span> (resolve(status)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board)</span> </span>{

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; <span class="hljs-title">row</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; <span class="hljs-title">col</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">9</span>)</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>) {
                row[i].insert(board[i][j]);
                col[j].insert(board[i][j]);
                block[i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>].insert(board[i][j]);
            }
        }
    }
    <span class="hljs-built_in">stack</span>&lt;statue&gt; status;
    status.push(statue(row, col, block, board));
    <span class="hljs-keyword">if</span> (resolve(status)) {
        board = status.top().board;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_Sudoku</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; &amp;board)</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"_____________________________________"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : board) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"|"</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> i : it) {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" |"</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-------------------------------------"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board = {
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'3'</span>},
        {<span class="hljs-string">'3'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'1'</span>},
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'.'</span>},
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'.'</span>},
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>},
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>},
        {<span class="hljs-string">'.'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>},
        {<span class="hljs-string">'5'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'8'</span>},
        {<span class="hljs-string">'4'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'.'</span>}};

    print_Sudoku(board);
    solveSudoku(board);
    print_Sudoku(board);
}</code></pre>
                </div>
            </div>
        </div>
    </div>



</body>

</html>